import {
  require_jsx_runtime
} from "./chunk-HIGUOLGR.js";
import {
  require_react
} from "./chunk-5NSVLCKE.js";
import {
  __toESM
} from "./chunk-DP4XHQAG.js";

// node_modules/@portabletext/react/dist/index.js
var import_jsx_runtime = __toESM(require_jsx_runtime());

// node_modules/@portabletext/toolkit/dist/index.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function isPortableTextSpan(node) {
  return node._type === "span" && "text" in node && typeof node.text == "string" && (typeof node.marks > "u" || Array.isArray(node.marks) && node.marks.every((mark) => typeof mark == "string"));
}
function isPortableTextBlock(node) {
  return (
    // A block doesn't _have_ to be named 'block' - to differentiate between
    // allowed child types and marks, one might name them differently
    typeof node._type == "string" && // Toolkit-types like nested spans are @-prefixed
    node._type[0] !== "@" && // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array
    (!("markDefs" in node) || !node.markDefs || Array.isArray(node.markDefs) && // Every mark definition needs to have an `_key` to be mappable in child spans
    node.markDefs.every((def) => typeof def._key == "string")) && // `children` is required and needs to be an array
    "children" in node && Array.isArray(node.children) && // All children are objects with `_type` (usually spans, but can contain other stuff)
    node.children.every((child) => typeof child == "object" && "_type" in child)
  );
}
function isPortableTextListItemBlock(block) {
  return isPortableTextBlock(block) && "listItem" in block && typeof block.listItem == "string" && (typeof block.level > "u" || typeof block.level == "number");
}
function isPortableTextToolkitList(block) {
  return block._type === "@list";
}
function isPortableTextToolkitSpan(span) {
  return span._type === "@span";
}
function isPortableTextToolkitTextNode(node) {
  return node._type === "@text";
}
var knownDecorators = ["strong", "em", "code", "underline", "strike-through"];
function sortMarksByOccurences(span, index, blockChildren) {
  if (!isPortableTextSpan(span) || !span.marks) return [];
  if (!span.marks.length) return [];
  const marks = span.marks.slice(), occurences = {};
  return marks.forEach((mark) => {
    occurences[mark] = 1;
    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {
      const sibling = blockChildren[siblingIndex];
      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) occurences[mark]++;
      else break;
    }
  }), marks.sort((markA, markB) => sortMarks(occurences, markA, markB));
}
function sortMarks(occurences, markA, markB) {
  const aOccurences = occurences[markA], bOccurences = occurences[markB];
  if (aOccurences !== bOccurences) return bOccurences - aOccurences;
  const aKnownPos = knownDecorators.indexOf(markA), bKnownPos = knownDecorators.indexOf(markB);
  return aKnownPos !== bKnownPos ? aKnownPos - bKnownPos : markA.localeCompare(markB);
}
function buildMarksTree(block) {
  var _a, _b;
  const {
    children
  } = block, markDefs = (_a = block.markDefs) != null ? _a : [];
  if (!children || !children.length) return [];
  const sortedMarks = children.map(sortMarksByOccurences), rootNode = {
    _type: "@span",
    children: [],
    markType: "<unknown>"
  };
  let nodeStack = [rootNode];
  for (let i = 0; i < children.length; i++) {
    const span = children[i];
    if (!span) continue;
    const marksNeeded = sortedMarks[i] || [];
    let pos = 1;
    if (nodeStack.length > 1) for (pos; pos < nodeStack.length; pos++) {
      const mark = ((_b = nodeStack[pos]) == null ? void 0 : _b.markKey) || "", index = marksNeeded.indexOf(mark);
      if (index === -1) break;
      marksNeeded.splice(index, 1);
    }
    nodeStack = nodeStack.slice(0, pos);
    let currentNode = nodeStack[nodeStack.length - 1];
    if (currentNode) {
      for (const markKey of marksNeeded) {
        const markDef = markDefs == null ? void 0 : markDefs.find((def) => def._key === markKey), markType = markDef ? markDef._type : markKey, node = {
          _type: "@span",
          _key: span._key,
          children: [],
          markDef,
          markType,
          markKey
        };
        currentNode.children.push(node), nodeStack.push(node), currentNode = node;
      }
      if (isPortableTextSpan(span)) {
        const lines = span.text.split(`
`);
        for (let line = lines.length; line-- > 1; ) lines.splice(line, 0, `
`);
        currentNode.children = currentNode.children.concat(lines.map((text) => ({
          _type: "@text",
          text
        })));
      } else currentNode.children = currentNode.children.concat(span);
    }
  }
  return rootNode.children;
}
function nestLists(blocks, mode) {
  const tree = [];
  let currentList;
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    if (block) {
      if (!isPortableTextListItemBlock(block)) {
        tree.push(block), currentList = void 0;
        continue;
      }
      if (!currentList) {
        currentList = listFromBlock(block, i, mode), tree.push(currentList);
        continue;
      }
      if (blockMatchesList(block, currentList)) {
        currentList.children.push(block);
        continue;
      }
      if ((block.level || 1) > currentList.level) {
        const newList = listFromBlock(block, i, mode);
        if (mode === "html") {
          const lastListItem = currentList.children[currentList.children.length - 1], newLastChild = _objectSpread(_objectSpread({}, lastListItem), {}, {
            children: [...lastListItem.children, newList]
          });
          currentList.children[currentList.children.length - 1] = newLastChild;
        } else currentList.children.push(newList);
        currentList = newList;
        continue;
      }
      if ((block.level || 1) < currentList.level) {
        const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, block);
        if (match) {
          currentList = match, currentList.children.push(block);
          continue;
        }
        currentList = listFromBlock(block, i, mode), tree.push(currentList);
        continue;
      }
      if (block.listItem !== currentList.listItem) {
        const matchingBranch = tree[tree.length - 1], match = matchingBranch && findListMatching(matchingBranch, {
          level: block.level || 1
        });
        if (match && match.listItem === block.listItem) {
          currentList = match, currentList.children.push(block);
          continue;
        } else {
          currentList = listFromBlock(block, i, mode), tree.push(currentList);
          continue;
        }
      }
      console.warn("Unknown state encountered for block", block), tree.push(block);
    }
  }
  return tree;
}
function blockMatchesList(block, list) {
  return (block.level || 1) === list.level && block.listItem === list.listItem;
}
function listFromBlock(block, index, mode) {
  return {
    _type: "@list",
    _key: `${block._key || `${index}`}-parent`,
    mode,
    level: block.level || 1,
    listItem: block.listItem,
    children: [block]
  };
}
function findListMatching(rootNode, matching) {
  const level = matching.level || 1, style = matching.listItem || "normal", filterOnType = typeof matching.listItem == "string";
  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || "normal") === style) return rootNode;
  if (!("children" in rootNode)) return;
  const node = rootNode.children[rootNode.children.length - 1];
  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;
}
function spanToPlainText(span) {
  let text = "";
  return span.children.forEach((current) => {
    isPortableTextToolkitTextNode(current) ? text += current.text : isPortableTextToolkitSpan(current) && (text += spanToPlainText(current));
  }), text;
}
var leadingSpace = /^\s/;
var trailingSpace = /\s$/;
function toPlainText(block) {
  const blocks = Array.isArray(block) ? block : [block];
  let text = "";
  return blocks.forEach((current, index) => {
    if (!isPortableTextBlock(current)) return;
    let pad = false;
    current.children.forEach((span) => {
      isPortableTextSpan(span) ? (text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? " " : "", text += span.text, pad = false) : pad = true;
    }), index !== blocks.length - 1 && (text += `

`);
  }), text;
}
var LIST_NEST_MODE_HTML = "html";

// node_modules/@portabletext/react/dist/index.js
var import_react = __toESM(require_react());
var _excluded = ["block", "list", "listItem", "marks", "types"];
var _excluded2 = ["listItem"];
var _excluded3 = ["_key"];
function ownKeys2(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
      _defineProperty2(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty2(e, r, t) {
  return (r = _toPropertyKey2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey2(t) {
  var i = _toPrimitive2(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _toPrimitive2(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o, r, i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(e);
    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.includes(n)) continue;
    t[n] = r[n];
  }
  return t;
}
var defaultLists = {
  number: ({
    children
  }) => (0, import_jsx_runtime.jsx)("ol", {
    children
  }),
  bullet: ({
    children
  }) => (0, import_jsx_runtime.jsx)("ul", {
    children
  })
};
var DefaultListItem = ({
  children
}) => (0, import_jsx_runtime.jsx)("li", {
  children
});
var link = ({
  children,
  value
}) => (0, import_jsx_runtime.jsx)("a", {
  href: value == null ? void 0 : value.href,
  children
});
var underlineStyle = {
  textDecoration: "underline"
};
var defaultMarks = {
  em: ({
    children
  }) => (0, import_jsx_runtime.jsx)("em", {
    children
  }),
  strong: ({
    children
  }) => (0, import_jsx_runtime.jsx)("strong", {
    children
  }),
  code: ({
    children
  }) => (0, import_jsx_runtime.jsx)("code", {
    children
  }),
  underline: ({
    children
  }) => (0, import_jsx_runtime.jsx)("span", {
    style: underlineStyle,
    children
  }),
  "strike-through": ({
    children
  }) => (0, import_jsx_runtime.jsx)("del", {
    children
  }),
  link
};
var getTemplate = (type, prop) => `[@portabletext/react] Unknown ${type}, specify a component for it in the \`components.${prop}\` prop`;
var unknownTypeWarning = (typeName) => getTemplate(`block type "${typeName}"`, "types");
var unknownMarkWarning = (markType) => getTemplate(`mark type "${markType}"`, "marks");
var unknownBlockStyleWarning = (blockStyle) => getTemplate(`block style "${blockStyle}"`, "block");
var unknownListStyleWarning = (listStyle) => getTemplate(`list style "${listStyle}"`, "list");
var unknownListItemStyleWarning = (listStyle) => getTemplate(`list item style "${listStyle}"`, "listItem");
function printWarning(message) {
  console.warn(message);
}
var hidden = {
  display: "none"
};
var DefaultUnknownType = ({
  value,
  isInline
}) => {
  const warning = unknownTypeWarning(value._type);
  return isInline ? (0, import_jsx_runtime.jsx)("span", {
    style: hidden,
    children: warning
  }) : (0, import_jsx_runtime.jsx)("div", {
    style: hidden,
    children: warning
  });
};
var DefaultUnknownMark = ({
  markType,
  children
}) => (0, import_jsx_runtime.jsx)("span", {
  className: `unknown__pt__mark__${markType}`,
  children
});
var DefaultUnknownBlockStyle = ({
  children
}) => (0, import_jsx_runtime.jsx)("p", {
  children
});
var DefaultUnknownList = ({
  children
}) => (0, import_jsx_runtime.jsx)("ul", {
  children
});
var DefaultUnknownListItem = ({
  children
}) => (0, import_jsx_runtime.jsx)("li", {
  children
});
var DefaultHardBreak = () => (0, import_jsx_runtime.jsx)("br", {});
var defaultBlockStyles = {
  normal: ({
    children
  }) => (0, import_jsx_runtime.jsx)("p", {
    children
  }),
  blockquote: ({
    children
  }) => (0, import_jsx_runtime.jsx)("blockquote", {
    children
  }),
  h1: ({
    children
  }) => (0, import_jsx_runtime.jsx)("h1", {
    children
  }),
  h2: ({
    children
  }) => (0, import_jsx_runtime.jsx)("h2", {
    children
  }),
  h3: ({
    children
  }) => (0, import_jsx_runtime.jsx)("h3", {
    children
  }),
  h4: ({
    children
  }) => (0, import_jsx_runtime.jsx)("h4", {
    children
  }),
  h5: ({
    children
  }) => (0, import_jsx_runtime.jsx)("h5", {
    children
  }),
  h6: ({
    children
  }) => (0, import_jsx_runtime.jsx)("h6", {
    children
  })
};
var defaultComponents = {
  types: {},
  block: defaultBlockStyles,
  marks: defaultMarks,
  list: defaultLists,
  listItem: DefaultListItem,
  hardBreak: DefaultHardBreak,
  unknownType: DefaultUnknownType,
  unknownMark: DefaultUnknownMark,
  unknownList: DefaultUnknownList,
  unknownListItem: DefaultUnknownListItem,
  unknownBlockStyle: DefaultUnknownBlockStyle
};
function mergeComponents(parent, overrides) {
  const {
    block,
    list,
    listItem,
    marks,
    types
  } = overrides, rest = _objectWithoutProperties(overrides, _excluded);
  return _objectSpread2(_objectSpread2({}, parent), {}, {
    block: mergeDeeply(parent, overrides, "block"),
    list: mergeDeeply(parent, overrides, "list"),
    listItem: mergeDeeply(parent, overrides, "listItem"),
    marks: mergeDeeply(parent, overrides, "marks"),
    types: mergeDeeply(parent, overrides, "types")
  }, rest);
}
function mergeDeeply(parent, overrides, key) {
  const override = overrides[key], parentVal = parent[key];
  return typeof override == "function" || override && typeof parentVal == "function" ? override : override ? _objectSpread2(_objectSpread2({}, parentVal), override) : parentVal;
}
function PortableText({
  value: input,
  components: componentOverrides,
  listNestingMode,
  onMissingComponent: missingComponentHandler = printWarning
}) {
  const handleMissingComponent = missingComponentHandler || noop, blocks = Array.isArray(input) ? input : [input], nested = nestLists(blocks, listNestingMode || LIST_NEST_MODE_HTML), components = (0, import_react.useMemo)(() => componentOverrides ? mergeComponents(defaultComponents, componentOverrides) : defaultComponents, [componentOverrides]), renderNode = (0, import_react.useMemo)(() => getNodeRenderer(components, handleMissingComponent), [components, handleMissingComponent]), rendered = nested.map((node, index) => renderNode({
    node,
    index,
    isInline: false,
    renderNode
  }));
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {
    children: rendered
  });
}
var getNodeRenderer = (components, handleMissingComponent) => {
  function renderNode(options) {
    const {
      node,
      index,
      isInline
    } = options, key = node._key || `node-${index}`;
    return isPortableTextToolkitList(node) ? renderList(node, index, key) : isPortableTextListItemBlock(node) ? renderListItem(node, index, key) : isPortableTextToolkitSpan(node) ? renderSpan(node, index, key) : hasCustomComponentForNode(node) ? renderCustomBlock(node, index, key, isInline) : isPortableTextBlock(node) ? renderBlock(node, index, key, isInline) : isPortableTextToolkitTextNode(node) ? renderText(node, key) : renderUnknownType(node, index, key, isInline);
  }
  function hasCustomComponentForNode(node) {
    return node._type in components.types;
  }
  function renderListItem(node, index, key) {
    const tree = serializeBlock({
      node,
      index,
      isInline: false,
      renderNode
    }), renderer = components.listItem, Li = (typeof renderer == "function" ? renderer : renderer[node.listItem]) || components.unknownListItem;
    if (Li === components.unknownListItem) {
      const style = node.listItem || "bullet";
      handleMissingComponent(unknownListItemStyleWarning(style), {
        type: style,
        nodeType: "listItemStyle"
      });
    }
    let children = tree.children;
    if (node.style && node.style !== "normal") {
      const {
        listItem
      } = node, blockNode = _objectWithoutProperties(node, _excluded2);
      children = renderNode({
        node: blockNode,
        index,
        isInline: false,
        renderNode
      });
    }
    return (0, import_jsx_runtime.jsx)(Li, {
      value: node,
      index,
      isInline: false,
      renderNode,
      children
    }, key);
  }
  function renderList(node, index, key) {
    const children = node.children.map((child, childIndex) => renderNode({
      node: child._key ? child : _objectSpread2(_objectSpread2({}, child), {}, {
        _key: `li-${index}-${childIndex}`
      }),
      index: childIndex,
      isInline: false,
      renderNode
    })), component = components.list, List = (typeof component == "function" ? component : component[node.listItem]) || components.unknownList;
    if (List === components.unknownList) {
      const style = node.listItem || "bullet";
      handleMissingComponent(unknownListStyleWarning(style), {
        nodeType: "listStyle",
        type: style
      });
    }
    return (0, import_jsx_runtime.jsx)(List, {
      value: node,
      index,
      isInline: false,
      renderNode,
      children
    }, key);
  }
  function renderSpan(node, _index, key) {
    const {
      markDef,
      markType,
      markKey
    } = node, Span = components.marks[markType] || components.unknownMark, children = node.children.map((child, childIndex) => renderNode({
      node: child,
      index: childIndex,
      isInline: true,
      renderNode
    }));
    return Span === components.unknownMark && handleMissingComponent(unknownMarkWarning(markType), {
      nodeType: "mark",
      type: markType
    }), (0, import_jsx_runtime.jsx)(Span, {
      text: spanToPlainText(node),
      value: markDef,
      markType,
      markKey,
      renderNode,
      children
    }, key);
  }
  function renderBlock(node, index, key, isInline) {
    const _serializeBlock = serializeBlock({
      node,
      index,
      isInline,
      renderNode
    }), {
      _key
    } = _serializeBlock, props = _objectWithoutProperties(_serializeBlock, _excluded3), style = props.node.style || "normal", Block = (typeof components.block == "function" ? components.block : components.block[style]) || components.unknownBlockStyle;
    return Block === components.unknownBlockStyle && handleMissingComponent(unknownBlockStyleWarning(style), {
      nodeType: "blockStyle",
      type: style
    }), (0, import_jsx_runtime.jsx)(Block, _objectSpread2(_objectSpread2({}, props), {}, {
      value: props.node,
      renderNode
    }), key);
  }
  function renderText(node, key) {
    if (node.text === `
`) {
      const HardBreak = components.hardBreak;
      return HardBreak ? (0, import_jsx_runtime.jsx)(HardBreak, {}, key) : `
`;
    }
    return node.text;
  }
  function renderUnknownType(node, index, key, isInline) {
    const nodeOptions = {
      value: node,
      isInline,
      index,
      renderNode
    };
    handleMissingComponent(unknownTypeWarning(node._type), {
      nodeType: "block",
      type: node._type
    });
    const UnknownType = components.unknownType;
    return (0, import_jsx_runtime.jsx)(UnknownType, _objectSpread2({}, nodeOptions), key);
  }
  function renderCustomBlock(node, index, key, isInline) {
    const nodeOptions = {
      value: node,
      isInline,
      index,
      renderNode
    }, Node = components.types[node._type];
    return Node ? (0, import_jsx_runtime.jsx)(Node, _objectSpread2({}, nodeOptions), key) : null;
  }
  return renderNode;
};
function serializeBlock(options) {
  const {
    node,
    index,
    isInline,
    renderNode
  } = options, children = buildMarksTree(node).map((child, i) => renderNode({
    node: child,
    isInline: true,
    index: i,
    renderNode
  }));
  return {
    _key: node._key || `block-${index}`,
    children,
    index,
    isInline,
    node
  };
}
function noop() {
}
export {
  PortableText,
  defaultComponents,
  mergeComponents,
  toPlainText
};
//# sourceMappingURL=@portabletext_react.js.map
